texts:
  en: Small CLs
  ja: 小さな CL
---
texts:
  en: Why Write Small CLs? {#why}
  ja: どうして小さな CL を書くのか？ {#why}
---
texts:
  en: "Small, simple CLs are:"
  ja: 小さくシンプルな CL には以下のような利点があります。
---
texts:
  en: >-
    **Reviewed more quickly.** It's easier for a reviewer to find five minutes
        several times to review small CLs than to set aside a 30 minute block to
        review one large CL.
  ja: >-
    **速くレビューできる。**レビュアーにとって、小さな CL をレビューするための 5 分間を数回確保するほうが、一度の大きな CL をレビューするための 30 分をまとめて確保するよりも容易です。
---
texts:
  en: >-
    **Reviewed more thoroughly.** With large changes, reviewers and authors tend
        to get frustrated by large volumes of detailed commentary shifting back and
        forth—sometimes to the point where important points get missed or dropped.
  ja: >-
    **隅々までレビューできる。**変更が大規模だとあっちこっちに詳細なコメントを大量に書かねばならず、レビュアーと作成者がストレスを感じやすくなります。ときには重要な点を見落としたり省略したりしてしまうこともあります。
---
texts:
  en: >-
    **Less likely to introduce bugs.** Since you're making fewer changes, it's
        easier for you and your reviewer to reason effectively about the impact of
        the CL and see if a bug has been introduced.
  ja: >-
    **バグが混入する可能性が減る。**変更箇所が少なければ、開発者もレビュアーも CL の影響範囲が予測しやすく、バグが混入したかどうかを見分けやすくなります。
---
texts:
  en: >-
    **Less wasted work if they are rejected.** If you write a huge CL and then
        your reviewer says that the overall direction is wrong, you've wasted a lot
        of work.
  ja: >
    **CL が却下されても無駄になる作業が少ない。**巨大な CL を書いてからレビュアーに全体的な方向性が間違っていると言われると、多くの作業が無駄になってしまいます。
---
texts:
  en: >-
    **Easier to merge.** Working on a large CL takes a long time, so you will
        have lots of conflicts when you merge, and you will have to merge
        frequently.
  ja: >-
    **マージしやすい。**大規模な CL での作業には時間がかかるため、マージする頃には多くのコンフリクトが発生し、頻繁にマージしなければならなくなります。
---
texts:
  en: >-
    **Easier to design well.** It's a lot easier to polish the design and code
        health of a small change than it is to refine all the details of a large
        change.
  ja: >-
    **設計を改善しやすくなる。**小さな変更の設計やコードの健康状態を改善するほうが、大きな変更の詳細をすべて見直して設計を洗練させるよりもずっと簡単です。
---
texts:
  en: >-
    **Less blocking on reviews.** Sending self-contained portions of your
        overall change allows you to continue coding while you wait for your current
        CL in review.
  ja: >-
    **レビューによって作業がブロックされなくなる。**あなたがしようとしている変更全体のうち一部を自己完結的な CL にして提出すれば、現在の CL のレビューを待つ間にコーディング作業を続けることができます。
---
texts:
  en: >-
    **Simpler to roll back.** A large CL will more likely touch files that get
        updated between the initial CL submission and a rollback CL, complicating
        the rollback (the intermediate CLs will probably need to be rolled back
        too).
  ja: >-
    **ロールバックしやすい。**大きな CL は多くのファイルにわたって変更するため、最初に CL を提出してからロールバックの CL までにそれらのファイルが変更され、ロールバックが複雑になります。（その CL 以降の CL もロールバックする必要が生じることもあります）
---
texts:
  en: >-
    Note that **reviewers have discretion to reject your change outright for the

    sole reason of it being too large.** Usually they will thank you for your

    contribution but request that you somehow make it into a series of smaller

    changes. It can be a lot of work to split up a change after you've already

    written it, or require lots of time arguing about why the reviewer should accept

    your large change. It's easier to just write small CLs in the first place.
  ja: >-
    注意していただきたいのですが、**レビュアーにはあなたの変更が大きすぎるというそれだけの理由でただちにその変更を却下できる裁量があります。**普通はそこまでせず、レビュアーはあなたの貢献に感謝しつつも、もっと小さな変更に分けて CL を送ってほしいとリクエストするでしょう。すでにコードを書いたあとで変更を分割するのは骨の折れる作業になりますし、あるいは巨大な変更を受け入れてもらうにしてもレビュアーが納得できるよう議論を交わすのにも多くの時間が必要になります。最初から小さな CL を書くほうが簡単です。
---
texts:
  en: What is Small? {#what_is_small}
  ja: 「小さい」とはどういうことか？ {#what_is_small}
---
texts:
  en: >-
    In general, the right size for a CL is **one self-contained change**. This means

    that:
  ja: 一般に、CL の適切なサイズは**単一の自己完結的な変更**です。これは以下のことを意味します。
---
texts:
  en: >-
    The CL makes a minimal change that addresses **just one thing**. This is
        usually just one part of a feature, rather than a whole feature at once. In
        general it's better to err on the side of writing CLs that are too small vs.
        CLs that are too large. Work with your reviewer to find out what an
        acceptable size is.
  ja: >-
    CL が**ただ一つのこと**に取り組むミニマルな変更を行っています。これは普通、ある機能の全体を一度に実装するというより、その中の一部分だけを実装する CL です。小さすぎる CL を書いて失敗するほうが大きすぎる CL を書いて失敗するよりもよほど良いです。レビュアーと協力してどんなサイズの CL なら受け入れられるかを探ってみてください。
---
texts:
  en: >-
    Everything the reviewer needs to understand about the CL (except future
        development) is in the CL, the CL's description, the existing codebase, or a
        CL they've already reviewed.
  ja: >-
    レビュアーがその CL について理解する必要のあるすべての情報 (将来の開発を除く) が CLや、CL ディスクリプション、既存のコードベース、これまでレビューした CL の中にあります。
---
texts:
  en: >-
    The system will continue to work well for its users and for the developers
        after the CL is checked in.
  ja: システムはその CL がチェックインされたあともユーザーにとっても開発者にとっても正常に動作し続けます。
---
texts:
  en: >-
    The CL is not so small that its implications are difficult to understand. If
        you add a new API, you should include a usage of the API in the same CL so
        that reviewers can better understand how the API will be used. This also
        prevents checking in unused APIs.
  ja: CL がその含意がわかりにくくなるほどに過剰に小さくはありません。新しい API を追加するのなら、同じ CL の中にその API の使い方を含めるべきです。それはレビュアーが API の使い方をきちんと理解できるようになるためです。こうすることは、使われていない API のチェックインを防止します。
---
texts:
  en: >-
    There are no hard and fast rules about how large is "too large." 100 lines is

    usually a reasonable size for a CL, and 1000 lines is usually too large, but

    it's up to the judgment of your reviewer. The number of files that a change is

    spread across also affects its "size." A 200-line change in one file might be

    okay, but spread across 50 files it would usually be too large.
  ja: >-
    どれほど大きければ「大きすぎる」と言えるのかを判断する厳密で手っ取り早いルールはありません。大雑把には 100 行の CL は適度なサイズで、1000 行になると大きすぎると言えますが、これもレビュアーの判断次第です。変更するファイル数も CL の「サイズ」に関係あります。200 行の変更が行われていてもそれが 1 つのファイルで完結していれば許容できるかもしれませんが、 50 ファイルにもわたる変更であれば普通は「大きすぎる」と判断されるでしょう。
---
texts:
  en: >-
    Keep in mind that although you have been intimately involved with your code from

    the moment you started to write it, the reviewer often has no context. What

    seems like an acceptably-sized CL to you might be overwhelming to your reviewer.

    When in doubt, write CLs that are smaller than you think you need to write.

    Reviewers rarely complain about getting CLs that are too small.
  ja: >-
    覚えておいていただきたいのですが、あなたはコードを書き始めた瞬間からコードに没頭していて目を閉じてもコードを思い浮かべられるとしても、レビュアーは何のコンテキストも持たないことがよくあります。あなたにとって許容範囲な CL のサイズのように思えても、レビュアーにとっては大きすぎるかもしれません。CL が小さすぎるからといってそのことで不満をこぼすレビュアーはめったにいません。
---
texts:
  en: When are Large CLs Okay? {#large_okay}
  ja: __COPY__
---
texts:
  en: "There are a few situations in which large changes aren't as bad:"
  ja: __COPY__
---
texts:
  en: >-
    You can usually count deletion of an entire file as being just one line of
        change, because it doesn't take the reviewer very long to review.
  ja: __COPY__
---
texts:
  en: >-
    Sometimes a large CL has been generated by an automatic refactoring tool
        that you trust completely, and the reviewer's job is just to sanity check
        and say that they really do want the change. These CLs can be larger,
        although some of the caveats from above (such as merging and testing) still
        apply.
  ja: __COPY__
---
texts:
  en: Splitting by Files {#splitting-files}
  ja: __COPY__
---
texts:
  en: >-
    Another way to split up a CL is by groupings of files that will require

    different reviewers but are otherwise self-contained changes.
  ja: __COPY__
---
texts:
  en: >-
    For example: you send off one CL for modifications to a protocol buffer and

    another CL for changes to the code that uses that proto. You have to submit the

    proto CL before the code CL, but they can both be reviewed simultaneously. If

    you do this, you might want to inform both sets of reviewers about the other CL

    that you wrote, so that they have context for your changes.
  ja: __COPY__
---
texts:
  en: >-
    Another example: you send one CL for a code change and another for the

    configuration or experiment that uses that code; this is easier to roll back

    too, if necessary, as configuration/experiment files are sometimes pushed to

    production faster than code changes.
  ja: __COPY__
---
texts:
  en: Separate Out Refactorings {#refactoring}
  ja: __COPY__
---
texts:
  en: >-
    It's usually best to do refactorings in a separate CL from feature changes or

    bug fixes. For example, moving and renaming a class should be in a different CL

    from fixing a bug in that class. It is much easier for reviewers to understand

    the changes introduced by each CL when they are separate.
  ja: __COPY__
---
texts:
  en: >-
    Small cleanups such as fixing a local variable name can be included inside of a

    feature change or bug fix CL, though. It's up to the judgment of developers and

    reviewers to decide when a refactoring is so large that it will make the review

    more difficult if included in your current CL.
  ja: __COPY__
---
texts:
  en: Keep related test code in the same CL {#test_code}
  ja: __COPY__
---
texts:
  en: >-
    Avoid splitting test code into a separate CL. Tests validating your code

    modifications should go into the same CL, even if it increases the code line

    count.
  ja: __COPY__
---
texts:
  en: >-
    However, <i>independent</i> test modifications can go into separate CLs first,

    similar to the [refactorings guidelines](#refactoring). That includes:
  ja: __COPY__
---
texts:
  en: validating pre-existing, submitted code with new tests.
  ja: __COPY__
---
texts:
  en: refactoring the test code (e.g. introduce helper functions).
  ja: __COPY__
---
texts:
  en: introducing larger test framework code (e.g. an integration test).
  ja: __COPY__
---
texts:
  en: Don't Break the Build {#break}
  ja: __COPY__
---
texts:
  en: >-
    If you have several CLs that depend on each other, you need to find a way to

    make sure the whole system keeps working after each CL is submitted. Otherwise

    you might break the build for all your fellow developers for a few minutes

    between your CL submissions (or even longer if something goes wrong unexpectedly

    with your later CL submissions).
  ja: __COPY__
---
texts:
  en: Can't Make it Small Enough {#cant}
  ja: __COPY__
---
texts:
  en: >-
    Sometimes you will encounter situations where it seems like your CL *has* to be

    large. This is very rarely true. Authors who practice writing small CLs can

    almost always find a way to decompose functionality into a series of small

    changes.
  ja: __COPY__
---
texts:
  en: >-
    Before writing a large CL, consider whether preceding it with a refactoring-only

    CL could pave the way for a cleaner implementation. Talk to your teammates and

    see if anybody has thoughts on how to implement the functionality in small CLs

    instead.
  ja: __COPY__
---
texts:
  en: >-
    If all of these options fail (which should be extremely rare) then get consent

    from your reviewers in advance to review a large CL, so they are warned about

    what is coming. In this situation, expect to be going through the review process

    for a long time, be vigilant about not introducing bugs, and be extra diligent

    about writing tests.
  ja: __COPY__
---
texts:
  en: "Next: [How to Handle Reviewer Comments](handling-comments.md)"
  ja: __COPY__
